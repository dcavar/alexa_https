/*
(C) 2017 by Damir Cavar (http://damir.cavar.me/), Rashmi Bidanta, Prateek Srivastava

to compile:
go build AlexaServer.go AlexaRequest.go

This program launches a HTTPS server and listens for requests from Amazon Alexa.
The JSON requests from Alexa contain an utterance that is transferred to the L715 Dispatcher.
If the utterance contains one of the common questions, an answer will be generated by pulling the subgraph
from the Knowledge Graph and running it through a Graph-2-Text mapper.
If the utterance is a statement, assertive, include the assertion in the knowledge graph.
*/


package main


import (
	"fmt"
	"encoding/json"
	"net/http"
	"log"
	"io/ioutil"
	"bytes"
	"strings"
)


// callDispatcher forwards the request string from Alexa to the Dispatcher.
// The Dispatcher consumes strings transmitted via XML-RPC.
func callDispatcher(text string) {
	/*
	simulate XML-RPC call:

	<?xml version="1.0"?>
	<methodCall>
	  <methodName>parse</methodName>
	  <params>
		<param>
			<value><string>John loves Mary</string></value>
		</param>
	  </params>
	</methodCall>
	*/
	var buffer bytes.Buffer
	// our XML-RPC exposed function is *parse* and it takes one string argument
	buffer.WriteString(`<?xml version="1.0"?><methodCall><methodName>parse</methodName><params><param><value><string>`)
	buffer.WriteString(text)
	buffer.WriteString(`</string></value></param></params></methodCall>`)

	client := &http.Client{}
	host := "localhost"
	port := "1234"
	req, err := http.NewRequest(http.MethodPost, "http://"+host+":"+port, strings.NewReader(buffer.String()))
	if err != nil {
		// handle error here
		log.Fatal(err)
	}
	req.Header.Add("Content-Type", "text/xml")
	var contLength = string(buffer.Len())
	req.Header.Add("Content-Length", contLength)
	_, err = client.Do(req)
	if err != nil {
		// handle error here
		log.Fatal(err)
	}
	fmt.Println("Success with submission to Dispatcher!")
}


func MyServer(w http.ResponseWriter, req *http.Request) {
	// just printing out some feedback
	fmt.Println("New request:")
	fmt.Println("------------------")

	// map for header keys and values
	var header map[string]string
	header = make(map[string]string)

	// process fome HTTP headers here
	for _, element := range []string{"Content-Type", "Host", "From", "Content-Language", "Content-Encoding", "Server", "Date", "User-Agent"} {
		// index is the index where we are
		// element is the element from someSlice for where we are
		v := req.Header.Get(element)
		if v != "" {
			fmt.Printf("%s: %s\n", element, v)
			header[element] = v
		}
	}
	fmt.Println("------------------")

	b, err := ioutil.ReadAll(req.Body)
	if err != nil {
		fmt.Println(err)
		err = req.Body.Close()
		if err != nil {
			fmt.Println(err)
		}
	} else {
		fmt.Println(string(b))
		jdata := &AlexaRequest{
			Session: &Session{},
			Context: &Context{},
			Request: &Request{},
		}
		// for this to work for all details of your skill, you need to implement the appropriate structs in the
		// AlexaRequest.go file
		err := json.Unmarshal(b, jdata)
		fmt.Println(err)
		// process the error here and respond accordingly, maybe return?

		w.Header().Set("Content-Type", "application/json; charset=UTF-8")
		w.WriteHeader(http.StatusOK)
		w.Write([]byte(`{"version": "1.0", "response": {"outputSpeech": {"type": "PlainText", "text": "This is an example response. Can I help you with anything else?"}, "shouldEndSession": true}}`))

		// TODO
		// Process the special skill properties here, or somewhere above

	}
}


func main() {
	// responding to requests (no sub-folders!)
	http.HandleFunc("/", MyServer)
	// follow the instructions at:
	// https://developer.amazon.com/docs/custom-skills/test-a-custom-skill.html#create-a-private-key-and-self-signed-certificate-for-testing
	// copy the certificate.pem content to the certificate field in your skill
	// configuration form
	err := http.ListenAndServeTLS(":443", "certificate.pem", "privatekey.pem", nil)
	if err != nil {
		log.Fatal("ListenAndServe: ", err)
	}
}

